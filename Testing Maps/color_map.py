# -*- coding: utf-8 -*-
"""Color_map

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qaN0gQIckIRvNA9LjSt84D7LaPFhTVBH
"""

import os
import numpy as np
import torch
import torch.nn.functional as F
from PIL import Image
from transformers import SegformerForSemanticSegmentation, SegformerImageProcessor

def load_image(path):
    """Carga una imagen y la convierte a RGB."""
    return Image.open(path).convert("RGB")

def predict_image(model, feature_extractor, image_path, target_size=(512, 512)):
    """
    Realiza la predicción de segmentación sobre una imagen y ajusta la resolución de salida.

    Args:
        model: Modelo Segformer entrenado.
        feature_extractor: Preprocesador de imagen.
        image_path: Ruta a la imagen de testing.
        target_size: Tamaño final deseado para la máscara de salida.

    Returns:
        Predicción en forma de máscara con índices de clase (0: background, 1: liver, 2: tumor).
    """
    image = load_image(image_path)
    encoding = feature_extractor(images=np.array(image), return_tensors="pt")
    pixel_values = encoding["pixel_values"]

    with torch.no_grad():
        outputs = model(pixel_values)

    logits = outputs.logits  # Shape: [batch_size, num_labels, H, W]

    # Interpolación de logits a 512x512 antes de aplicar argmax
    logits_up = F.interpolate(logits, size=target_size, mode="bilinear", align_corners=False)
    predicted_mask = torch.argmax(logits_up, dim=1).squeeze(0).cpu().numpy()

    return predicted_mask

def apply_color_map(mask):
    """
    Aplica un mapa de colores a la máscara de segmentación.

    Mapeo:
      - 0: background -> negro [0, 0, 0]
      - 1: liver -> verde [0, 255, 0]
      - 2: tumor -> rojo [255, 0, 0]

    Args:
        mask: Array 2D con índices de clase.

    Returns:
        Imagen de la máscara coloreada (array 3D en formato uint8).
    """
    color_map = np.array([
        [0, 0, 0],      # 0: Background (negro)
        [0, 255, 0],    # 1: Liver (verde)
        [255, 0, 0]     # 2: Tumor (rojo)
    ], dtype=np.uint8)

    colored_mask = color_map[mask]
    return colored_mask

def main():
    # Actualiza estas rutas según tu entorno en Compute Canada
    model_save_path = "/content/drive/MyDrive/ELAP_Project/models/test_1.0/model_test_1.0"  # Ruta del modelo entrenado
    test_img_dir = "/content/drive/MyDrive/testing/imagesTs"  # Directorio de imágenes de testing en PNG
    output_dir = "/content/drive/MyDrive/testing/results_color_map"  # Directorio para guardar las predicciones
    os.makedirs(output_dir, exist_ok=True)

    # Cargar el modelo y el feature extractor
    feature_extractor = SegformerImageProcessor.from_pretrained(model_save_path)
    model = SegformerForSemanticSegmentation.from_pretrained(model_save_path)
    model.eval()  # Modo evaluación

    # Listar imágenes de testing (se asume extensión .png)
    test_images = [f for f in os.listdir(test_img_dir) if f.lower().endswith(".png")]
    print(f"Se encontraron {len(test_images)} imágenes de testing.")

    # Procesar cada imagen y guardar la máscara coloreada sin necesidad de redimensionamiento extra
    for img_name in test_images:
        img_path = os.path.join(test_img_dir, img_name)
        pred_mask = predict_image(model, feature_extractor, img_path)
        colored_mask = apply_color_map(pred_mask)

        # Guardar la imagen con la resolución correcta (512x512)
        output_path = os.path.join(output_dir, f"pred_{img_name}")
        Image.fromarray(colored_mask).save(output_path)
        print(f"Procesada {img_name} -> {output_path}")

if __name__ == '__main__':
    main()