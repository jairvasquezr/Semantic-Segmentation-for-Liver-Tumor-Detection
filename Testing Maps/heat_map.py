# -*- coding: utf-8 -*-
"""Heat_map

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xCSDKF_E2pj3zxq3ZzH3NB62WH66Wvmp

Al ser la máscara un arreglo con valores discretos (0, 1, 2), el heat map se visualizará como tres bandas de color
"""

import os
import numpy as np
import torch
import torch.nn.functional as F
from PIL import Image
import cv2
from transformers import SegformerForSemanticSegmentation, SegformerImageProcessor

def load_image(path):
    """Carga una imagen y la convierte a RGB."""
    return Image.open(path).convert("RGB")

def predict_tumor_probability(model, feature_extractor, image_path, target_size=(512, 512)):
    """
    Realiza la predicción de la probabilidad para la clase tumor.

    Args:
        model: Modelo Segformer entrenado.
        feature_extractor: Preprocesador de imagen.
        image_path: Ruta de la imagen.
        target_size: Resolución deseada de salida (por ejemplo, 512x512).

    Returns:
        Mapa de probabilidad (valores entre 0 y 1) para la clase tumor.
    """
    image = load_image(image_path)
    encoding = feature_extractor(images=np.array(image), return_tensors="pt")
    pixel_values = encoding["pixel_values"]

    with torch.no_grad():
        outputs = model(pixel_values)

    logits = outputs.logits  # Shape: [1, num_labels, H, W]

    # Extraer el canal correspondiente al tumor (se asume que tumor es la etiqueta 2)
    tumor_logits = logits[:, 2:3, :, :]  # Shape: [1, 1, H, W]

    # Interpolar a la resolución deseada
    tumor_logits_up = F.interpolate(tumor_logits, size=target_size, mode="bilinear", align_corners=False)

    # Convertir los logits a probabilidad usando sigmoid (para un solo canal)
    tumor_prob = torch.sigmoid(tumor_logits_up)

    # Eliminar dimensiones extra y convertir a NumPy
    tumor_prob = tumor_prob.squeeze().cpu().numpy()  # Forma: (H, W)

    return tumor_prob

def apply_heatmap_with_smoothing(prob_map, kernel_size=(11, 11)):
    """
    Aplica un suavizado a la probabilidad y genera un heat map usando el colormap JET.

    Args:
        prob_map: Mapa de probabilidad (valores entre 0 y 1).
        kernel_size: Tamaño del kernel para el suavizado (debe ser impar, p.ej., (11,11)).

    Returns:
        Heat map en formato uint8.
    """
    # Aplicar suavizado con un filtro gaussiano para obtener un gradiente suave
    prob_map_smoothed = cv2.GaussianBlur(prob_map, kernel_size, 0)

    # Normalizar los valores a [0, 255]
    norm_prob = ((prob_map_smoothed - prob_map_smoothed.min()) /
                 (prob_map_smoothed.max() - prob_map_smoothed.min() + 1e-7)) * 255
    norm_prob = norm_prob.astype(np.uint8)

    # Aplicar el colormap JET; en este colormap, los valores altos se mapean a rojo
    heat_map = cv2.applyColorMap(norm_prob, cv2.COLORMAP_JET)
    return heat_map

def main():
    # Actualiza estas rutas según tu entorno (Compute Canada u otro)
    model_save_path = "/content/drive/MyDrive/ELAP_Project/models/test_1.0/model_test_1.0"  # Ruta del modelo entrenado
    test_img_dir = "/content/drive/MyDrive/testing/imagesTs"  # Directorio de imágenes de testing en PNG
    output_dir = "/content/drive/MyDrive/testing/results_heat_map"  # Directorio para guardar las predicciones heat map
    os.makedirs(output_dir, exist_ok=True)

    # Cargar el modelo y el feature extractor
    feature_extractor = SegformerImageProcessor.from_pretrained(model_save_path)
    model = SegformerForSemanticSegmentation.from_pretrained(model_save_path)
    model.eval()  # Modo evaluación

    # Listar imágenes de testing (se asume extensión .png)
    test_images = [f for f in os.listdir(test_img_dir) if f.lower().endswith(".png")]
    print(f"Se encontraron {len(test_images)} imágenes de testing.")

    for img_name in test_images:
        img_path = os.path.join(test_img_dir, img_name)

        # Obtener el mapa de probabilidad para la clase tumor
        tumor_prob = predict_tumor_probability(model, feature_extractor, img_path, target_size=(512,512))

        # Aplicar el suavizado y generar el heat map
        heat_map = apply_heatmap_with_smoothing(tumor_prob, kernel_size=(11,11))

        output_path = os.path.join(output_dir, f"heat_{img_name}")
        cv2.imwrite(output_path, heat_map)
        print(f"Procesada {img_name} -> {output_path}")

if __name__ == '__main__':
    main()

import os
import cv2
import numpy as np

def convert_ground_truth_mask(mask_path, output_path):
    # Leer la máscara en escala de grises
    mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
    if mask is None:
        print(f"Error al leer: {mask_path}")
        return

    # Definir el mapeo
    color_map = {0: 0, 1: 128, 2: 255}
    # Aplicar el mapeo utilizando vectorize
    vectorized_map = np.vectorize(lambda x: color_map.get(x, 0))
    mask_converted = vectorized_map(mask).astype(np.uint8)

    cv2.imwrite(output_path, mask_converted)
    print(f"Guardado: {output_path}")

def process_masks_directory(input_dir, output_dir):
    os.makedirs(output_dir, exist_ok=True)

    for filename in os.listdir(input_dir):
        if filename.lower().endswith(".png"):
            input_path = os.path.join(input_dir, filename)
            output_path = os.path.join(output_dir, f"mapped_{filename}")
            convert_ground_truth_mask(input_path, output_path)

# Ejemplo de uso:
input_masks_dir = "/content/drive/MyDrive/testing/labelsTs"  # Directorio con las máscaras originales
output_masks_dir = "/content/drive/MyDrive/testing/labelsTs_grises"     # Directorio donde se guardarán las máscaras convertidas

process_masks_directory(input_masks_dir, output_masks_dir)

# ======================== Heat_map_2 =======================

import os
import numpy as np
import torch
import torch.nn.functional as F
from PIL import Image
import cv2
from transformers import SegformerForSemanticSegmentation, SegformerImageProcessor

def load_image(path):
    """Carga una imagen y la convierte a RGB."""
    return Image.open(path).convert("RGB")

def predict_tumor_probability(model, feature_extractor, image_path, target_size=(512, 512)):
    """
    Realiza la predicción de la probabilidad para la clase tumor.

    Args:
        model: Modelo Segformer entrenado.
        feature_extractor: Preprocesador de imagen.
        image_path: Ruta de la imagen.
        target_size: Resolución deseada de salida (por ejemplo, 512x512).

    Returns:
        Mapa de probabilidad (valores entre 0 y 1) para la clase tumor.
    """
    image = load_image(image_path)
    encoding = feature_extractor(images=np.array(image), return_tensors="pt")
    pixel_values = encoding["pixel_values"]

    with torch.no_grad():
        outputs = model(pixel_values)

    logits = outputs.logits  # Shape: [1, num_labels, H, W]

    # Extraer el canal correspondiente al tumor (se asume que tumor es la etiqueta 2)
    tumor_logits = logits[:, 2:3, :, :]  # Shape: [1, 1, H, W]

    # Interpolar a la resolución deseada
    tumor_logits_up = F.interpolate(tumor_logits, size=target_size, mode="bilinear", align_corners=False)

    # Convertir los logits a probabilidad usando sigmoid (para un solo canal)
    tumor_prob = torch.sigmoid(tumor_logits_up)

    # Eliminar dimensiones extra y convertir a NumPy
    tumor_prob = tumor_prob.squeeze().cpu().numpy()  # Forma: (H, W)

    return tumor_prob

def apply_heatmap_with_smoothing(prob_map, kernel_size=(11, 11), prob_threshold=0.1):
    """
    Aplica un suavizado, umbral, normalización robusta y operaciones morfológicas para generar un heat map.

    Args:
        prob_map: Mapa de probabilidad (valores entre 0 y 1).
        kernel_size: Tamaño del kernel para el suavizado gaussiano (debe ser impar, e.g., (11,11)).
        prob_threshold: Umbral mínimo de probabilidad para considerar una activación válida.

    Returns:
        Heat map en formato uint8.
    """
    # 1. Suavizado gaussiano para obtener un gradiente suave
    prob_map_smoothed = cv2.GaussianBlur(prob_map, kernel_size, 0)

    # 2. Aplicar umbral para descartar activaciones espurias
    prob_map_thresh = np.where(prob_map_smoothed < prob_threshold, 0, prob_map_smoothed)

    # 3. Normalización robusta utilizando percentiles (1 y 99)
    lower = np.percentile(prob_map_thresh, 1)
    upper = np.percentile(prob_map_thresh, 99)
    norm_prob = (prob_map_thresh - lower) / (upper - lower + 1e-7)
    norm_prob = np.clip(norm_prob, 0, 1) * 255
    norm_prob = norm_prob.astype(np.uint8)

    # 4. Operación morfológica: apertura para eliminar pequeñas regiones ruidosas
    morph_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    norm_prob = cv2.morphologyEx(norm_prob, cv2.MORPH_OPEN, morph_kernel)

    # 5. Generar el heat map usando el colormap JET (valores altos se mapean a rojo)
    heat_map = cv2.applyColorMap(norm_prob, cv2.COLORMAP_JET)
    return heat_map

def main():
    # Actualiza estas rutas según tu entorno (Compute Canada u otro)
    model_save_path = "/content/drive/MyDrive/ELAP_Project/models/test_1.0/model_test_1.0"  # Ruta del modelo entrenado
    test_img_dir = "/content/drive/MyDrive/testing/imagesTs"  # Directorio de imágenes de testing en PNG
    output_dir = "/content/drive/MyDrive/testing/results_heat_map_2"  # Directorio para guardar las predicciones heat map
    os.makedirs(output_dir, exist_ok=True)

    # Cargar el modelo y el feature extractor
    feature_extractor = SegformerImageProcessor.from_pretrained(model_save_path)
    model = SegformerForSemanticSegmentation.from_pretrained(model_save_path)
    model.eval()  # Modo evaluación

    # Listar imágenes de testing (se asume extensión .png)
    test_images = [f for f in os.listdir(test_img_dir) if f.lower().endswith(".png")]
    print(f"Se encontraron {len(test_images)} imágenes de testing.")

    for img_name in test_images:
        img_path = os.path.join(test_img_dir, img_name)

        # Obtener el mapa de probabilidad para la clase tumor
        tumor_prob = predict_tumor_probability(model, feature_extractor, img_path, target_size=(512, 512))

        # Aplicar el suavizado, umbral, normalización robusta y operaciones morfológicas para generar el heat map
        heat_map = apply_heatmap_with_smoothing(tumor_prob, kernel_size=(11, 11), prob_threshold=0.1)

        output_path = os.path.join(output_dir, f"heat_{img_name}")
        cv2.imwrite(output_path, heat_map)
        print(f"Procesada {img_name} -> {output_path}")

if __name__ == '__main__':
    main()