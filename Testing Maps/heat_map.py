# -*- coding: utf-8 -*-
"""Heat_map

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xCSDKF_E2pj3zxq3ZzH3NB62WH66Wvmp
"""

import os
import numpy as np
import torch
import torch.nn.functional as F
from PIL import Image
import cv2
from transformers import SegformerForSemanticSegmentation, SegformerImageProcessor

def load_image(path):
    """Carga una imagen y la convierte a RGB."""
    return Image.open(path).convert("RGB")

def predict_tumor_probability(model, feature_extractor, image_path, target_size=(512, 512)):
    """
    Performs the probability prediction for the tumor class.

    Args:
        model: Trained Segformer model.
        feature_extractor: Image preprocessor.
        image_path: Image path.
        target_size: 512x512.

    Returns:
        tumor probability map (btw 0 and 1).
    """
    image = load_image(image_path)
    encoding = feature_extractor(images=np.array(image), return_tensors="pt")
    pixel_values = encoding["pixel_values"]

    with torch.no_grad():
        outputs = model(pixel_values)

    logits = outputs.logits  # Shape: [1, num_labels, H, W]

    # Extract the channel corresponding to the tumor (tumor is class 2)
    tumor_logits = logits[:, 2:3, :, :]  # Shape: [1, 1, H, W]

    # Interpolate to the desired resolution
    tumor_logits_up = F.interpolate(tumor_logits, size=target_size, mode="bilinear", align_corners=False)

    # Convert logits to probability using sigmoid (for a single channel)
    tumor_prob = torch.sigmoid(tumor_logits_up)

    # Remove extra dimensions and convert to NumPy
    tumor_prob = tumor_prob.squeeze().cpu().numpy()  # Forma: (H, W)

    return tumor_prob

def apply_heatmap_with_smoothing(prob_map, kernel_size=(11, 11)):
    # Apply smoothing with a Gaussian filter to obtain a smooth gradient
    prob_map_smoothed = cv2.GaussianBlur(prob_map, kernel_size, 0)

    # Normalization [0, 255]
    norm_prob = ((prob_map_smoothed - prob_map_smoothed.min()) /
                 (prob_map_smoothed.max() - prob_map_smoothed.min() + 1e-7)) * 255
    norm_prob = norm_prob.astype(np.uint8)

    # Apply colormap JET
    heat_map = cv2.applyColorMap(norm_prob, cv2.COLORMAP_JET)
    return heat_map

def main():
    # Paths
    model_save_path = "/content/drive/MyDrive/ELAP_Project/models/test_1.0/model_test_1.0"  
    test_img_dir = "/content/drive/MyDrive/testing/imagesTs"  
    output_dir = "/content/drive/MyDrive/testing/results_heat_map"  
    os.makedirs(output_dir, exist_ok=True)

    # Load the model and the feature extractor
    feature_extractor = SegformerImageProcessor.from_pretrained(model_save_path)
    model = SegformerForSemanticSegmentation.from_pretrained(model_save_path)
    model.eval()  # Modo evaluación

    # Testing images (.png)
    test_images = [f for f in os.listdir(test_img_dir) if f.lower().endswith(".png")]
    print(f"Se encontraron {len(test_images)} imágenes de testing.")

    for img_name in test_images:
        img_path = os.path.join(test_img_dir, img_name)

        # Obtain the probability map for the tumor class
        tumor_prob = predict_tumor_probability(model, feature_extractor, img_path, target_size=(512,512))

        # Apply smoothing and generate the heat map
        heat_map = apply_heatmap_with_smoothing(tumor_prob, kernel_size=(11,11))

        output_path = os.path.join(output_dir, f"heat_{img_name}")
        cv2.imwrite(output_path, heat_map)
        print(f"Procesada {img_name} -> {output_path}")

if __name__ == '__main__':
    main()
